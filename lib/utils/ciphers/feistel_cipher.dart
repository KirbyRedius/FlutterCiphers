class FeistelCipher {
  /// Функция F, используемая в каждом раунде шифрования.
  /// Принимает правую половину данных и ключ раунда.
  /// Формула: f(x, k) = (x << 1) ⊕ (x << 5) ⊕ k
  /// Результат ограничивается 4 битами (маска 0x0F).
  static int func(int rightHalf, int roundKey) {
    return ((rightHalf << 1) ^ (rightHalf << 5) ^ roundKey) & 0x0F;
  }

  /// Шифрует данные с использованием алгоритма Фейстеля.
  /// Принимает:
  /// - plainText: исходные данные (8 бит, где 4 старших бита — левая половина, 4 младших — правая).
  /// - key: ключ шифрования.
  /// - rounds: количество раундов (по умолчанию 3).
  /// Возвращает зашифрованные данные.
  static int encrypt(int plainText, int key, {int rounds = 3}) {
    // Разделяем исходные данные на левую и правую половины.
    int leftHalf = (plainText >> 4) & 0x0F; // Левая половина (4 старших бита).
    int rightHalf = plainText & 0x0F; // Правая половина (4 младших бита).

    // Выполняем указанное количество раундов.
    for (int round = 0; round < rounds; round++) {
      // Сохраняем текущую правую половину во временной переменной.
      int temp = rightHalf;

      // Обновляем правую половину: XOR левой половины и результата функции F.
      rightHalf = leftHalf ^ func(rightHalf, key);

      // Обновляем левую половину: присваиваем ей значение из временной переменной.
      leftHalf = temp;
    }

    // Соединяем левую и правую половины и возвращаем результат.
    return (leftHalf << 4) | rightHalf;
  }

  /// Дешифрует данные, зашифрованные алгоритмом Фейстеля.
  /// Принимает:
  /// - cipherText: зашифрованные данные (8 бит, где 4 старших бита — левая половина, 4 младших — правая).
  /// - key: ключ шифрования.
  /// - rounds: количество раундов (по умолчанию 3).
  /// Возвращает расшифрованные данные.
  static int decrypt(int cipherText, int key, {int rounds = 3}) {
    // Разделяем зашифрованные данные на левую и правую половины.
    int leftHalf = (cipherText >> 4) & 0x0F; // Левая половина (4 старших бита).
    int rightHalf = cipherText & 0x0F; // Правая половина (4 младших бита).

    // Выполняем раунды в обратном порядке.
    for (int round = rounds - 1; round >= 0; round--) {
      // Сохраняем текущую левую половину во временной переменной.
      int temp = leftHalf;

      // Обновляем левую половину: XOR правой половины и результата функции F.
      leftHalf = rightHalf ^ func(leftHalf, key);

      // Обновляем правую половину: присваиваем ей значение из временной переменной.
      rightHalf = temp;
    }

    // Соединяем левую и правую половины и возвращаем результат.
    return (leftHalf << 4) | rightHalf;
  }
}
